##### 路由跳转

1. 方式一：
   `<router-link :to="/xxx"></router-link>`

- 缺点：会产生太多组件，性能很不好

2. 方式二：

- 编程式导航：
  标签内

```js
@click.prevent="$router.push({
  name:"xxx" // 命名路由
  query:{}
})"
```

- 缺点：导致绑定的事件太多？。。。

3. 方式三：事件委托

- 委托给父级 ---事件冒泡的机制 获取到目标元素
- 给父级绑定事件：事件的`target`属性可以获取到目标元素
- 如何获取到所需参数？
  已知：得到触发事件目标元素
  解决：给元素设置自定义属性，:data-xxx 通过自定义属性得到需要的参数
  在标签中 设置自定义属性：
  `:data-xxx="xxx.xx"`
- 方法中 使用`e.target.dataset` 元素自定义属性对 象 可以获取到所有的自定义属性 结构拿到所需要的数据

  - 注：遍历项 绑定事件 优先考虑能不能使用事件委托--性能更好

###### 保留 params 参数

- 当点击列表某一项跳转后 浏览器地址栏保留 params 参数
- 判断 params 是否有参数，有就加上
- params 参数 必须配合命名路由使用

###### 发送请求复用

- 为了不重复发送一样的请求，在发送请求之前判断 Vuex 有没有数据，有就不发了，没有就发送 (减少请求次数)
  `if(this.xxx.length) return`

##### 模拟后台数据 mock

- 将来后台没有及时给到接口数据，那么，我们就可以 通过 mockjs 生成随机数据， 模拟后台数据
- 下载安装 mock.js
- npm i mockjs

创建 mock 文件夹--->a 文件(原数据)--->ra(随机数据)

- 搭建接口--->store 中引入接口文件--->

###### buzhou

- 拆分组件

1. api--封装接口--->store--定义获取数据方式(vuex) 定义一个初始化状态数据--actions中定义一个发送请求的函数，第一个参数{commit}(用来触发mutations)，第二个参数 data={} 将来需要传入的参数数据都在data对象中-->定义mutations() 第一个参数所有数据state,第二个参数 需要获取的数据--->组件中引入 映射到组件 获取到数据渲染
