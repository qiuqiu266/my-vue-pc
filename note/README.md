##### 路由跳转

- 组件中路由两个相关对象(面试问题)
- \$router:路由器对象，包含一些路由跳转的方法--> push(),replace(),back()
- \$route:当前路由路由相关信息对象，包含当前路由相关信息数据对象---> path/name/query/params/meat

1. 方式一：
   `<router-link :to="/xxx"></router-link>`

- 缺点：会产生太多组件，性能很不好

2. 方式二：

- 编程式导航：
  标签内

```js
@click.prevent="$router.push({
  name:"xxx" // 命名路由
  query:{}
})"
```

- 缺点：导致绑定的事件太多？。。。

3. 方式三：事件委托

- 委托给父级 ---事件冒泡的机制 获取到目标元素
- 给父级绑定事件：事件的`target`属性可以获取到目标元素
- 如何获取到所需参数？
  已知：得到触发事件目标元素
  解决：给元素设置自定义属性，:data-xxx 通过自定义属性得到需要的参数
  在标签中 设置自定义属性：
  `:data-xxx="xxx.xx"`
- 方法中 使用`e.target.dataset` 元素自定义属性对 象 可以获取到所有的自定义属性 结构拿到所需要的数据

  - 注：遍历项 绑定事件 优先考虑能不能使用事件委托--性能更好

###### 保留 params 参数

- 当点击列表某一项跳转后 浏览器地址栏保留 params 参数
- 判断 params 是否有参数，有就加上
- params 参数 必须配合命名路由使用

###### 发送请求复用

- 为了不重复发送一样的请求，在发送请求之前判断 Vuex 有没有数据，有就不发了，没有就发送 (减少请求次数)
  `if(this.xxx.length) return`

##### 模拟后台数据 mock

- 将来后台没有及时给到接口数据，那么，我们就可以 通过 mockjs 生成随机数据， 模拟后台数据
- 下载安装 mock.js
- npm i mockjs

创建 mock 文件夹--->a 文件(原数据)--->ra(随机数据)

- 搭建接口--->store 中引入接口文件--->

###### buzhou

- 拆分组件

1. api--封装接口--->store--定义获取数据方式(vuex) 定义一个初始化状态数据--actions 中定义一个发送请求的函数，第一个参数{commit}(用来触发 mutations)，第二个参数 data={} 将来需要传入的参数数据都在 data 对象中-->定义 mutations() 第一个参数所有数据 state,第二个参数 需要获取的数据--->组件中引入 映射到组件 获取到数据渲染

###### search 组件删除关键字

绑定点击事件---清空 options---min.js 定义全局事件总线--header 组件 mounted 中绑定自定义事件--search 组件清空 header 组件的 keyword---

###### 添加品牌

- 父级中定义一个添加品牌的方法---参数为要添加的属性(品牌)--把要添加的属性加到整个数组中 options--this.options.xxx = xxx;---调用方法 更新数据---props 方式传给子组件--子组件接受---html 中给每个品牌绑定点击事件调用父级传过来的添加的方法并传入参数----

###### 添加属性(proops 是一个数组 存储多个属性 prop)

- 父级组件定义绑定添加的方法函数,参数为单个属性--将传入的属性使用 push 方法添加到数组中--调用方法 更新数据--自定义事件方式传入子级组件--@xxx="xxx"--子级组件触发：@click="\$emit('xxx',参数)"--(提示自定义事件需要符合 xx-xx 命名)---父级组件中遍历展示(遍历的是数组，有值才会展示，所以此处不需要 v-show)----2.删除品牌属性---可以使用 splice()方法 下标删除某个元素(需要传入参数为 index)--调用更新方法更新数据。

###### 使用 font 字体图标

scrollBehavior:滚动条行为--->点击页面跳转后页面显示最顶部

###### 购物车

测试接口-----配置路由----封装接口---使用 vuex---映射到组件--渲染展示动态数据---

- 不使用 vuex,发送请求 this.\$store.dispatch("接口函数",{参数})

当改变商品数量的时候，
失去焦点的时候发送更新的请求--
判断输入的数量只能是数字，并且不能大于库存和小于 1
当手动输入数量的时候，需要判断输入的数量大于 1 并且小于库存，同时 输入的数量是大于还是小于当前的数量，并计算。(大于库存了就不能再加了，小于 1 就不能再减了---:disabled="cart.skuNum===1（限制的数量）)

###### 未登录不允许访问的组件

- 某些组件是不允许未登录用户访问的，所以访问前需要判断是否登录过，不允许访问的组件可能不止一个，所以可以复用 方便调用，使用路由导航守卫
- 路由导航守卫
  - 全局守卫
  - 独享守卫
    - 必须有添加购物车操作才能去成功添加购物车页面，需要使用独享守卫，没有添加就去购物车页面
     - 
  - 组件守卫
  - token 存储在 localStorage 中 为了自动登录
- 除了 localStorage 以外的所有数据都存储在内存中，刷新浏览器就会消失(临时存储)，如果频繁使用就要存储一份在内存中（vuex 性能能好）
- 因为每次发送请求都要携带 token(存储登录的凭据)

1. 先判断 要跳转的路由地址是否包含需要登录后才能访问的地址 并且 未登录，不满足条件就 让其跳转到登录页面去登录才能访问 反则 就调用 next() 放行

2) 当跳转刷新其他页面的时候 通过 token 判断是否登录了，所有数据都是存储在内存中的，一旦刷新 就都没了，所以需要将 token 存在在 localStorage 中(持久性存储)

###### 登录

1. 使用


###### 订单信息列表
1. 封装接口函数---（不使用vuex）直接去组件中引入接口---定义初始化状态数据---mounted 中 发送请求---遍历展示动态数据---选择收件人信息（某一个被选中）--将被选中后的 selected 属性改为动态的---定义一个是否选中的标识----

###### 图片懒加载
1. npm i vue-lazyload
2. 配置
      plugins/lazyload.js
3. min.js 中引入
4. 使用
     组件中将图片属性 :src 改成 v-lozy

###### 项目打包
1. 打包
  - npm run build
2. 下载 全局安装
  -  npm i serve -g
3. 运行
  - serve -s dist
* 路由组件懒加载
 - vue的异步组件，异步加载组件
 1. 所有引入组件方式注释掉 换成箭头函数形式
   `import Home from "@views/Home";`
   只有路由组件加载的时候才调用，然后异步加载js文件，实现按需加载